# ラムダのテストです
## ソースコード
 1. LambdaAbbreviation.java
   * ラムダの省略記法のテストです
 2. LambdaInterface.java
   * 関数型いtんたフェースのテストです
 3. 


## ラムダとは
   * 簡潔に書ける匿名クラスとメソッド
   * http://www.lambdafaq.org/what-is-a-lambda-expression/

## ラムダとは　ラムダが導入された理由を探る
   * 関数型プログラミング言語でラムダは評価が高かった。Javaではいままで匿名クラスがあったがそれだと書き方が冗長。
   * Javaプログラマは、冗長な書き方に我慢強い。冗長な匿名クラスで我慢していたのになぜ今さら簡潔な書き方が必要か？（答）ストリームAPI。
   * ストリームAPIがなぜ必要か？(答)マルチコアのコンピュータで並列処理をさせる必要があり、並列処理をするために複雑化するFORループの実装隠ぺいしたかったから。
   * http://www.lambdafaq.org/why-are-lambda-expressions-being-added-to-java/
   * Javaはオブジェクト指向であり、データとコードをセットにした単位を扱うのが原則、コード単位で扱うのは原則に反する。メソッドへの参照を持つことができない。
   * そこで、Javaでは、コードのみを疑似的に扱うために、抽象メソッドを一つもつインタフェースの実装で関数を表す
   * Javaのラムダは、Javaの匿名クラスのオブジェクトの一種として扱われ、その原理・原則に従いつつ、”メソッド１つだけ持つインタフェースの実装”を完結に表現する方法を提供する
   
 ## ラムダに近いもの
  * 匿名クラス
  * Callbackイディオム --- 細部のロジックだけ実装し、それをどう呼び出すかはフレームワークに任せる
  * Commandパターン Observerパターン Strategyパターン Template MethodパターンとFactoryメソッドの組み合わせ
  * Internal Iteration(Iteratorパターン)から External Iteration（ストリーム）へ
  
## ラムダの使いどころ
  * 匿名クラスで使うところはなんでもオッケー
  * 匿名クラスの使いどころ
    * RunnableやFutureなど、マルチスレッド化・非同期化
   
## Link
  *
    * http://d.hatena.ne.jp/nowokay/20130824
  * 
    * http://masatoshitada.hatenadiary.jp/entry/2015/02/09/190150
  * ラムダがCommandパターンなどを言語的にサポートできるようになった
    * https://codezine.jp/article/detail/8300
  * Oracleのチュートリアル　
    * http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html
  
## 関数型プログラミングとは何かを考える
  * 関数型プログラミング = コードブロックをオブジェクトとみなす
  * オブジェクト指向プログラミング = コードとデータをセットでオブジェクトとみなす
  * 関数は、入力が定まると出力が定まるもの。オブジェクトは、状態と入力が決まると出力が定まるもの
  * ラムダに与える入力が一意に決まると出力が決まるか？NO.レキシカルスコープといって、ラムダを定義したメソッドやクラスが持つ変数の状態をひきずっている。

## ラムダ式を成立させる要素：　省略書式、関数型インタフェース、型推論、レキシカルスコープ、
  * 型推論
    * ラムダの代入文の左辺の型から推測することで、右辺の記述（クラス名、引数型名、リターンコード）を削減することに成功している
    * ラムダの代入文なら左辺を見れば目で終えるが、ラムダをメソッドの引数として渡すときは、そのメソッドの定義までたどる必要がある。
    * ストリームAPIで何段ものメソッドチェーンを組み立てると、推論の根拠がどこにあるのか目で追えなくなる。ここがラムダが可読性に問題があるといわれる理由の一つ。
    * ラムダ式は何クラスのインスタンスとして扱われるか？　（答）定義したときの左辺の型によって異なり、コンパイラが決める
    * http://masatoshitada.hatenadiary.jp/entry/2015/02/09/190150

  
## ラムダと匿名クラスの機能的な違い
  * 以下以外、機能的に、違いはない
  * this が表すもの
    * 匿名クラスは匿名クラスを表す。ラムダは、ラムダ定義を含むクラスを表す
    * 匿名クラスはインスタンス化するたび違うTHIS。ラムダは同じTHIS。
  * 匿名クラス内の変数が使えない
    * 匿名クラスは、あくまでクラス。基底クラス内に変数を持つことができ、匿名クラスはそれを継承して状態を持てる
    * ラムダは、疑似的に関数を表す。関数型インタフェース内に変数を持ち、状態を持つことはできない
  * http://www.bbreak.co.jp/technique/doc/java8/JavaSE8_Lambda.pdf

  
## 既に用意されている代表的な関数型インタフェース
  * Supplier.get() --- 引数無しで実行し、VOID以外の戻り値を返す
  * Consumer.accept() --- 引数を１つとり実行するが戻り値はVOID。VBAでいうサブルーチン
  * Predicate.test() --- 引数を１つとり、boolean型の戻り値を返す。チェックに使う。
  * Function.apply() --- 引数を１つとり実行し、VOID以外の戻り値を返す。VBAのFunction
  * Runnable.run() --- 引数無しで実行し、戻り値はVoid。Threadを実装するためのものだが、関数型インタフェースの条件を満たしている。
  * Callable.call() --- 引数無しで実行し、戻り値はVoid以外。並列処理を実装するためのものだが、関数型インタフェースの条件を満たしている。
  * http://www.ne.jp/asahi/hishidama/home/tech/java/functionalinterface.html

 * メソッド参照
  * 既に定義されているメソッドをラムダとして切り出すことができる
  

